# Me








## 自我介绍 

我是谁 + 学习经历 + 工作经历 + 项目经历 + 成绩成就 + 胜任理由 = 自我介绍

面试官你好，我叫 xx，从 xx 毕业，专业是 xx...，因xxx 和前端结缘。

第一家公司技术 100 多人，在这家公司主要 红酒商城系统、旅游系统、企业应用、政务系统等，主要用到xxx技术，前端 6 人，前期主要承担主力开发人员，后期一些项目的主要负责人，同时开始带人开发。获得 2017 年团队最佳员工奖。

第二家公司技术 300 多人，APP 端内嵌的 h5 项目，小程序，客服系统、大数据系统、冬奥会系统、车联网系统等十几个项目，主要用到 xxx 技术，前端 20 人，前期主要承担主力开发人员，后期开始带小伙伴一起做项目。

第三家公司部门100个人，主要做日志中心、mlops、低代码问卷平台、运维平台、其他数据平台等，主要用到 xxx 技术。前期带几个外包一起开发，后期主力开发人员。年度团队协作奖

总得来说，这几年做的各类项目比较多，同时也注重工程化建设，提高开发效率等，喜欢做团队中难度高的项目，后期也开始关注业务，关注用户体验，优化项目。

最新关注：StyleX、量子吸引、vite rust

## 项目 

1. 微前端
    - 背景 多项目合一，登录，公共模块，技术栈（公共模块升级和管理、技术栈差异、用户体验差）
    - 调研 iframe、single-spa、qiankun、micro-app、无界
    - 问题 子应用资源访问全部通过主应用进行，主应用通过 activeRule 识别子应用，通过 fetch 的方式请求子应用对应的 html 文件，从而激活子应用，所以主应用的 main.js 等资源需要放到域名根目录下
    - 问题 主应用未触发 fetch 的动作，也就不会去获取子应用的资源 由于路由配置规范不统一，子应用路由被网关的配置拦截
    - 在一般的情况下，用 qiankun 的数据传递方式就可以，但是对于复杂数据，或者在自定义导航的情况下，qiankun 数据传递就会由于网速等原因在某些地方监听不到数据
    - 问题 main.js 要放到域名根目录下、前端资源部署到OSS，前端访问不再走网关、依赖循环、联调问题、html缓存问题
    - 结果 多合一、共享公共能力
    - 原理 qiankun（single-spa + sandbox + import-html-entry）、Shadow DOM、Proxy
2. 埋点
   - 背景 其他部门的方案不合适、特殊参数上传、耗时埋点等
   - 技术 gif（跨域、远离dom，不阻塞、体积小，节约流量）
   - 成果 7个 项目接入
3. 站内信
   - 背景
   - 设计
4. 图表大盘
   - 背景 核心功能、体验
   - 技术 排序、布局、拖拉拽、主题、全屏、暗黑、水印
   - 难点 加载、排序、新建
5. 智能检索
   - 背景 kibana es7 kql 查询
   - 难点 语法分析、大小写转换、前置修改、键盘操作
6. 工程规范、项目模板
   - eslint、git commit、分支规范、code review、模板、脚手架、工具库
7. 低代码
   - 背景 内部没有、外部暴漏公司用户信息、文档无法当 url 用
   - 技术 Function(`"use strict";const formData = ${JSON.stringify(formData)};return (${string})`)()
   - 技术 动态关联
   - 成果 生成 url、10 分钟/人、4 期 7 个产品
8. 性能优化
   - 首次内容绘制 (First Contentful Paint，FCP) 1.8s 3s
   - 最大内容绘制 (Largest Contentful Paint，LCP) 2.5s 4s
   - 首次输入延迟 (First Input Delay ，FID) 100ms 300ms
   - 交互到绘制延迟（Interaction to Next Paint，INP）200ms 500ms
   - 累积布局偏移 (Cumulative Layout Shift，CLS) 0.1 0.25
   - 第一字节时间 (Time to First Byte，TTFB) 800ms 1800ms
   - 预取回 Prefetch <link rel="prefetch"
   - 预加载 Preload <link rel="preload"
   - 预连接 Preconnect <link rel="preconnect"
   - DNS预取回 DNS-Prefetch <link rel="dns-prefetch"
   - 加载指标：秒开率
   - 稳定性指标：资源错误,JS报错,Crash,内存堆栈,接口报错等
   - 操作体验指标：响应延迟，卡顿，滚动流畅性，TTI（可交互时间） FID(用户首次和页面交互到页面响应交互的时间)
   - 加载链路的优化：从访问url到页面呈现，整个加载渲染链路可以做优化的思路
   - CRP 关键渲染路径
   - 减少请求数量、减少请求体积、加载顺序、资源合并压缩、GZIP
   - 缓存（Service Worke、HttpCache）
   - DNS 解析
   - 图片处理优化（选择合适的图片、压缩、svg、base64、异步加载）
   - url-》页面
     - url 解析
     - 缓存（强缓存 Expires / Cache-Control、协商缓存 Last-Modified / ETag、数据缓存）
     - DNS解析（20~120毫秒、dns-prefetch、CDN 加速）
     - TCP三次握手（SYN、AYN+ACK、ACK）
     - 数据传输
     - TCP四次挥手（FIN、ACK、ACK+FIN、ACK）
     - 页面渲染（async、defer）
   - vue
     - 路由懒加载
     - 按需引入
     - KeepAlive

**图表库的选择**

主流的 web 图表库有：ECharts、Highcharts、D3.js、antv（G2，G6，F2）...

**ECharts**，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 `ZRender`，提供直观，交互丰富，可高度个性化定制的数据可视化图表。

**ECharts** 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。

**Highcharts** 是一个用纯 JavaScript 编写的一个图表库， 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表，HighCharts 支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。但非商业免费，商业需授权。

**D3** 的全称是（Data-Driven Documents）。D3.js是一个 JavaScript 库（是一个被数据驱动的文档），用于在浏览器中创建交互式可视化。

**D3** js库允许我们在数据集的上下文中操作网页的元素。这些元素可以是 HTML，SVG，或画布元素，可以根据数据集的内容进行引入，删除或编辑.它是一个用于操作 DOM 对象的库. D3.js 可以成为数据探索的宝贵帮助，它可以让您控制数据的表示，并允许您添加交互性。

**@antv/g2** 是一套基于可视化编码的图形语法，以数据驱动，具有高度的易用性和扩展性，用户无需关注各种繁琐的实现细节，一条语句即可构建出各种各样的可交互的统计图表。

**@antv/g2** 是一个图形语法, 通过数据之间的关系, 来生成一张图. 所以 G2 的定制化确实更加强大, 但是我们做业务的, 一般就是需要一个特定的图然后填充数据, 和将数据和数据之间的关系描述出来再实现图表有点出入，还有 G2 的文档一般，上手难度。

其中最后的选择落在 echarts 和 G2，echart 使用就是一些配置项，G2 是图形语法，通过数据之间关系，来生成一张图，虽说这样 G2 定制化更加强大。但是我们的业务，一般就是需要一个特定的图然后再填充数据，还能支持配置，无疑 Echarts 更符合我们的业务场景。所以最终图表库选择 **echarts** 。

## 工程化、模块化

- 工具化：以针对各自业务场景开发脚手架为主，内置常用的前端组件库，提供代码格式检查、埋点及监控等插件，提升项目初始化的效率。
- 规范化：面向完成需求的整个研发流程，梳理需求管理、视觉交互设计、评审、开发、联调、测试验收、上线部署和质量监控等相关的规范，进一步建设工具来约束研发过程中的不确定性。
- 平台化：将支撑研发的有关工具和系统聚合起来，通过套件和插件的设计模式，实现对不同场景的支撑，支持在线初始化项目，横向打通研发的整体链路。
- 体系化：紧跟前沿技术，集成低代码、在线IDE、代码智能生成或推荐等能力，建设需求、设计、研发、运营一体化的云开发平台。

## webpack

- JS 模块打包工具
  - 通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用
  - `打包功能` 和一套 `文件处理机制`，然后通过生态中的各种 `Loader` 和 `Plugin` 对代码进行预编译和打包

- Entry: 入口文件，Webpack 会从该文件开始进行分析与编译；
- Output: 出口路径，打包后创建 bundler 的文件路径以及文件名；
- Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；
- Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；
- Loader: 模块加载器，进行各种文件类型的加载与转换；
- Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；

### 工作流程 (加载 - 编译 - 输出)

1. 读取配置文件，按命令 `初始化` 配置参数，创建 `Compiler` 对象；
2. 调用插件的 `apply` 方法 `挂载插件` 监听，然后从入口文件开始执行编译；
3. 按文件类型，调用相应的 `Loader` 对模块进行 `编译`，并在合适的时机点触发对应的事件，调用 `Plugin` 执行，最后再根据模块 `依赖查找` 到所依赖的模块，递归执行第三步；
4. 将编译后的所有代码包装成一个个代码块 (`Chuck`)， 并按依赖和配置确定 `输出内容`。这个步骤，仍然可以通过 Plugin 进行文件的修改;
5. 最后，根据 `Output` 把文件内容一一写入到指定的文件夹中，完成整个过程；

- `模块机制`: webpack 自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制；
- `文件编译`: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理；

### Loader

- Webpack 其实是`只能识别 js 模块`，`Loader 不同格式文件转换器`，对 Webpack 传入的字符串进行按需修改
- 将代码进行分析，`构建 AST (抽象语法树)`， 遍历进行定向的修改后，再重新生成新的代码字符串

*** `Babel-loader` 会执行以下步骤: ***

1. babylon 将 ES6/ES7 代码解析成 AST
2. babel-traverse 对 AST 进行遍历转译，得到新的 AST
3. 新 AST 通过 babel-generator 转换成 ES5

**Loader 特性:**

- `链式传递`，按照配置时相反的顺序链式执行；
- 基于 Node 环境，拥有 `较高权限`，比如文件的增删查改；
- 可同步也可异步；

**编写原则:**

- `单一原则`: 每个 Loader 只做一件事；
- `链式调用`: Webpack 会按顺序链式调用每个 Loader；
- `统一原则`: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

### Plugin

见网页

## vite

- esbuild（10～100 倍）（go 直接转机器码、go 多线程共享内存、多核 cpu、零造轮子、复用 AST 节点）

   - 预构建依赖
   - go 直接转机器码，而非 js 先解析字节码再转机器码，js 解释性语言，go 编译性语言
   - go 多线程共享内存、多核 cpu 运行打包算法
   - 零造轮子
   - 复用 AST 节点，高效的内存利用
   - 在资源打包这种 CPU 密集场景下，Go 性能更优。一般来说，JS 的操作是毫秒级，而 Go 则是纳秒级。
   - js：解释运行、parse、解释运行、link、解释运行、generation
   - go：parse、link、generation
   - Go 在线程之间共享内存，而 js 必须在线程之间序列化数据。
   - Go 和 JavaScript 都有`并行的垃圾收集器`，Go 的堆在`所有线程之间共享`，而每个 JS 线程中都有一个`单独的堆`。

- rollup

## Rust

vivo 蓝河操作系统采用 Rust 编写「系统框架」—— 从源头避免了内存使用不当引起的安全漏洞

- 高性能 内存利用率极高、没有运行时和垃圾回收
- 可靠性 丰富的类型系统和所有权模型保证了`内存安全和线程安全`
- 生产力 出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具 —— 包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等

Rust 语言可以用于开发：

- 传统命令行程序 - 直接生成目标可执行程序，不需要任何解释程序。
- Web 应用 - 被编译成 WebAssembly，WebAssembly 是一种 JS 的高效替代品。
  - WebAssembly，是通过虚拟机的方式，可以在服务端、客户端如浏览器等环境执行的二进制程序。他有速度快、效率高、可移植的特点。
  - 对我们 Web 前端工程最大的好处就是可以在浏览器端使用二进制程序处理一些计算量大的处理，使用他比 javascript 快的特点优化性能。
- 网络服务器 - 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。
- 嵌入式设备 - 同时具有 JS 一般的高效开发语法和 C 语言的执行效率，支持底层平台的开发。

## 前端打包工具对比

>四款前端主流的打包工具：grunt ， gulp，webpack， rollup，以发布时间为顺序。

### Grunt：

最老牌的打包工具，它`运用配置的思想来写打包脚本，一切皆配置`，所以会出现比较多的配置项，诸如option,src,dest等等。而且不同的插件可能会有自己扩展字段，认知成本高，运用的时候需要明白各种插件的配置规则。

MPA，老牌打包工具，基于文件为媒介（运行慢，零散的脚本文件一当多起来就受到影响

### Gulp：

用代码方式来写打包脚本，并且代码采用流式的写法，只抽象出了gulp.src, gulp.pipe, gulp.dest, gulp.watch 接口，运用相当简单。更易于学习和使用，使用gulp的代码量能比grunt少一半左右。

MPA，易学，基于 nodejs 的 steam 流打包

### webpack: 

是模块化管理工具和打包工具。通过 loader 的转换，任何形式的资源都可以视作模块，比如 Commonjs 模块、AMD 模块、ES6 模块、css、图片等。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。它定位是模块打包器，而 Gulp/Grunt 属于构建工具。Webpack 可以代替 Gulp/Grunt 的一些功能，但不是一个职能的工具，可以配合使用。

SPA，目前最强大的打包工具，但是过于臃肿，如何单纯打包js不推荐

### Rollup：

下一代 ES6 模块化工具，最大的亮点是利用 ES6 模块设计，利用 tree-shaking生成更简洁、更简单的代码。一般而言，对于应用使用 Webpack，对于类库使用 Rollup；需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多 Commonjs 模块的依赖时，使用 webpack。代码库是基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 Rollup。

MPA，tree-shaking特性（针对es6，按需打包，多余的不要，目前（2018，vuex,react主流使用）



## 浏览器内核

## ES6

- let、const
- 解构
- Set、WeakSet、Map、WeakMap
  - WeakSet 结构与 Set 类似，也是不重复的值的集合。WeakSet 的成员只能是对象和 Symbol 值
  - WeakSet 中的对象都是弱引用
- Proxy

```js
var obj = new Proxy({}, {
  get: function (target, propKey, receiver) {
      console.log(`getting ${propKey}!`);
      return Reflect.get(target, propKey, receiver);
  },
  set: function (target, propKey, value, receiver) {
      console.log(`setting ${propKey}!`);
      return Reflect.set(target, propKey, value, receiver);
  }
});
```
