# Me

python node nest next

## 表现

1. 乐观积极
2. 主动沟通
3. 逻辑顺畅
4. 上进有责任心
5. 有主张、做事果断

1. 业务能力
2. 思考能力
3. 学习能力
4. 无上限的付出

1. 目标是什么
   - 业务上专家，技术上大牛
2. 近阶段的目标
   - 融入团队，提高团队，能打的一个团队
3. 长期目标
   - 做出一个电商界优秀案例
4. 方式方法
   - 整合现有问题，结合自身经验改进
   - 积极投入到业务建设
   - 技术上攻坚，带领团队
   - 借鉴其他部门、其他公司
5. 多赞美公司、多赞美面试官

## 想问的问题

- 前端工程化、性能优化、用户体验
- 组件设计、产品场景
- node、跨端、数据可视化
- 低代码、BFF、高并发、高性能
- http
- vue、react
- 大数据渲染

## 自我介绍

我是谁 + 学习经历 + 工作经历 + 项目经历 + 成绩成就 + 胜任理由 = 自我介绍

面试官你好，我叫 xx，从 xx 毕业，因 xxx 和前端结缘，现在将近 8 年的工作经验，认为和咱们公司这个岗位比较匹配就投递了一下。

第一家公司技术 100 多人，在这家公司主要 红酒商城系统、旅游系统、企业应用、政务系统等，主要用到xxx技术，前端 6 人，前期主要承担主力开发人员，后期一些项目的主要负责人，同时开始带人开发。获得 2017 年团队最佳员工奖。

第二家公司技术 300 多人，APP 端内嵌的 h5 项目，小程序，客服系统、大数据系统、冬奥会系统、车联网系统等十几个项目，主要用到 xxx 技术，前端 20 人，前期主要承担主力开发人员，后期开始带小伙伴一起做项目。

第三家公司在技术中台，部门 100 个人，云服务产品（容器、日志、网关、mlops、运维平台），大数据产品（日志、数据查询、服务、质量），自研低代码问卷平台等，主要用到 xxx 技术。前期带几个外包一起开发，后期主力开发人员。年度团队协作奖。产品、设计、解决方案等。

总得来说，这几年做的各类项目比较多，同时也注重工程化建设，提高开发效率等，帮助团队，喜欢做团队中难度高的项目，后期也开始关注业务，关注用户体验，优化项目。

最新关注：StyleX、量子吸引、vite rust rolldown

## 项目  

### 1. 微前端

    - 背景 多项目合一，登录，公共模块，技术栈（公共模块升级和管理、技术栈差异、用户体验差）
    - 调研 iframe、single-spa、qiankun、micro-app、无界

    - iframe 性能问题、路由管理困难、通信机制限制等

    - `single-spa` 只是实现了加载器、路由托管
    
    - `无界 和 Micro App` 通过 `webComponent` 动态加载子应用
    - 无界采用 iframe 做为沙箱方案
    - micro-app 0.x 版本采用 with 沙箱，1.x 支持 vite 后，支持和无界同样的 ifame 沙箱。

    - 问题：需要在主应用的某个路由页面加载微应用？
    - 1. 必须保证微应用加载时主应用这个路由页面也加载了。vue + vue-router 技术栈的主应用：
    - 2. 主应用注册这个路由时给 path 加一个 *，
    - 需要注意：如果这个路由有其他子路由，需要另外注册一个路由，仍然使用这个组件即可。
    - 3. 微应用的 activeRule 需要包含主应用的这个路由 path。
    - 4. 在这个组件的 mounted 周期调用 start 函数，需要注意：不要重复调用。

    - 问题：如何解决子应用给 window 对象添加事件处理函数不生效的问题？
    - 1. 由于子应用访问的 window 对象是被 qiankun 代理后的对象，因此直接给 window 对象添加事件处理函数是无效的，
    - 2. 可以通过 addEventListener 给 window 添加事件监听器来解决该问题：
    - 3. window.addEventListener('eventName', eventHandler);

   - 问题：微应用文件更新之后，访问的还是旧版文件，老是让用户清缓存。
   - 服务器需要给微应用的 index.html 配置一个响应头：Cache-Control no-cache，意思就是每次请求都检查是否更新。
   - location = /index.html {
      add_header Cache-Control no-cache;
   }

   - 问题：微应用打包之后 css 中的字体文件和图片加载 404
   - 原因是 qiankun 将外链样式改成了内联样式，但是字体文件和背景图片的加载路径是相对路径。
   - 而 css 文件一旦打包完成，就无法通过动态修改 publicPath 来修正其中的字体文件和背景图片的路径。
   - 1. 所有图片等静态资源上传至 cdn，css 中直接引用 cdn 地址（推荐）
   - 2. 借助 webpack 的 url-loader 将字体文件和图片打包成 base64（适用于字体文件和图片体积小的项目）（推荐）
   - 3. 借助 webpack 的 file-loader ，在打包时给其注入完整路径（适用于字体文件和图片体积比较大的项目）
   - 4. 将两种方案结合起来，小文件转 base64 ，大文件注入路径前缀

    - 问题：微前端主应用部署在 k8s容器 上（自依赖），
    - 问题：容器平台前端部署在对象存储 oss，对象存储又部署在 k8s容器 上（循环依赖）
    - 1. 将微前端主应用在容器和阿里云都部署了一份，容器平台前端资源部署在阿里云。
    - 2. 访问容器平台的链路如图中蓝色箭头所示，通过网关匹配到 k8s-fe 路由将流量转发到阿里云主应用，主应用再请求阿里云的容器平台资源。
    - 3. 其他平台访问链路不变，如图红色箭头所示，通过网关将流量转发到容器的主应用，主应用拉取对象存储上各产品的资源。
    - 4. 主应用和所有子应用都在容器平台发布更新版本，主应用发布时会同时上传一份资源到阿里云，容器平台资源会上传阿里云，其他产品资源上传对象存储。

    - 结果 多合一、共享公共能力
    - 原理 qiankun（single-spa + sandbox + import-html-entry）、Shadow DOM、Proxy
    - 1、`监视路由 window.location.pathname` 等相关变化，触发接下来的匹配逻辑
    - 2、`匹配子应用 重写路由 window.popState, replaceState`，在保留原有功能的基础上，
    - 增加子应用 entry 映射相关逻辑针对变化的路由，匹配子应用
    - 3、`加载子应用 import-html-entry` 解析入口文件中的 html 和 script, 
    - 动态创建script去执行jsCode, 通过umd模块获取子应用，调用子应用 mount 方法，render 子应用
    - 4、`渲染子应用 把 js 和 html`，渲染到提前预留的#app容器中
    
### 2. 埋点
   
   见 ./frontend/log_sdk.md 内容

### 3. 站内信
   
   见 ./frontend/mail.md 内容

### 4. 图表大盘
   - 背景 核心功能、体验
   - 技术 排序、布局、拖拉拽、主题、全屏、暗黑、水印
   - 难点 加载、排序、新建

### 图表库的选择

主流的 web 图表库有：ECharts、Highcharts、D3.js、antv（G2，G6，F2）...

**ECharts**，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 `ZRender`，提供直观，交互丰富，可高度个性化定制的数据可视化图表。

**ECharts** 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。

**Highcharts** 是一个用纯 JavaScript 编写的一个图表库， 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表，HighCharts 支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。但非商业免费，商业需授权。

**D3** 的全称是（Data-Driven Documents）。D3.js是一个 JavaScript 库（是一个被数据驱动的文档），用于在浏览器中创建交互式可视化。

**D3** js库允许我们在数据集的上下文中操作网页的元素。这些元素可以是 HTML，SVG，或画布元素，可以根据数据集的内容进行引入，删除或编辑.它是一个用于操作 DOM 对象的库. D3.js 可以成为数据探索的宝贵帮助，它可以让您控制数据的表示，并允许您添加交互性。

**@antv/g2** 是一套基于可视化编码的图形语法，以数据驱动，具有高度的易用性和扩展性，用户无需关注各种繁琐的实现细节，一条语句即可构建出各种各样的可交互的统计图表。

**@antv/g2** 是一个图形语法, 通过数据之间的关系, 来生成一张图. 所以 G2 的定制化确实更加强大, 但是我们做业务的, 一般就是需要一个特定的图然后填充数据, 和将数据和数据之间的关系描述出来再实现图表有点出入，还有 G2 的文档一般，上手难度。

其中最后的选择落在 echarts 和 G2，echart 使用就是一些配置项，G2 是图形语法，通过数据之间关系，来生成一张图，虽说这样 G2 定制化更加强大。但是我们的业务，一般就是需要一个特定的图然后再填充数据，还能支持配置，无疑 Echarts 更符合我们的业务场景。所以最终图表库选择 **echarts** 。

   - [见掘金文章地址](https://juejin.cn/post/7208472817459789885)

### 5. 智能检索
   - 背景 kibana es7 kql 查询
   - 难点 语法分析、大小写转换、前置修改、键盘操作

   - [见掘金文章地址](https://juejin.cn/post/7210593177820676154)

### 6. 工程规范、项目模板
   - eslint、git commit、分支规范、code review、模板、脚手架、工具库

   - [见掘金文章地址](https://juejin.cn/post/7091202054680985630)

### 7. 低代码
   - 背景 内部没有、外部暴漏公司用户信息、文档无法当 url 用
   - 技术 Function(`"use strict";const formData = ${JSON.stringify(formData)};return (${string})`)()
   - 技术 动态关联
   - 撤销、重做（快照、限制保存快照的容量，超出容量直接删除前面最早的快照即可）
   - 撤销、重做（两个栈记录每次操作记录，维护的难度也会越来越高）
   - 成果 生成 url、10 分钟/人、4 期 7 个产品

   - [见掘金文章地址](https://juejin.cn/post/7078860542026186765)

### 8. 性能优化
   - 首次内容绘制 (First Contentful Paint，FCP) 1.8s 3s
   - 最大内容绘制 (Largest Contentful Paint，LCP) 2.5s 4s
   - 首次输入延迟 (First Input Delay ，FID) 100ms 300ms
   - 交互到绘制延迟（Interaction to Next Paint，INP）200ms 500ms
   - 累积布局偏移 (Cumulative Layout Shift，CLS) 0.1 0.25
   - 第一字节时间 (Time to First Byte，TTFB) 800ms 1800ms
   - 预取回 Prefetch <link rel="prefetch"
   - 预加载 Preload <link rel="preload"
   - 预连接 Preconnect <link rel="preconnect"
   - DNS预取回 DNS-Prefetch <link rel="dns-prefetch"
   - 加载指标：秒开率
   - 稳定性指标：资源错误,JS报错,Crash,内存堆栈,接口报错等
   - 操作体验指标：响应延迟，卡顿，滚动流畅性，TTI（可交互时间） FID(用户首次和页面交互到页面响应交互的时间)
   - 加载链路的优化：从访问url到页面呈现，整个加载渲染链路可以做优化的思路
   - CRP 关键渲染路径
   - 减少请求数量、减少请求体积、加载顺序、资源合并压缩、GZIP
   - 元素背景图使用雪碧图模式，是前端基本优化手段，可以显著降低请求次数。
   - 缓存（Service Worke、HttpCache）
   - DNS 解析
   - 图片处理优化（选择合适的图片、压缩、svg、base64、异步加载）
   - url-》页面
     - url 解析
     - 缓存（强缓存 Expires / Cache-Control、协商缓存 Last-Modified / ETag、数据缓存）
     - DNS解析（20~120毫秒、dns-prefetch、CDN 加速）
     - TCP三次握手（SYN、AYN+ACK、ACK）
     - 数据传输
     - TCP四次挥手（FIN、ACK、ACK+FIN、ACK）
     - 页面渲染（async、defer）
   - vue
     - 路由懒加载
     - 按需引入
     - KeepAlive

## 高并发场景

- 春晚活动页
- 首屏资源主要包括：HTML文档、JavaScript、CSS以及样式图片。
- 由于这是单页面应用，我们可以通过常规技术将JS和CSS进行打包。
- 对于样式图片，我们可以通过按需加载的方式，显著减小首屏资源体积。
- 通过拆分优化，首屏的样式图片体积减少约41%。
- 再加上 CDN 降质和 WebP 参数的优化，样式图片的体积可以降低到 178KB。
- 同时，我们将需要单独加载的击鼓游戏精灵动画图从首屏加载清单中剥离，使得首屏样式图片的加载次数从2次减少到1次。
- 这样一来，用户在打开页面时，所需的请求次数和资源体积都得到了显著降低，进而提高了用户体验。
- 设计团队将3D动画转化为精灵图，并将不变部分（如鼓架）单独抽离。
- 精灵图仅包含运动部分（如鼓面敲击动画），有效降低资源消耗。
- 通过抽帧方式将击鼓精灵图从24帧降至4帧，大小从1236KB降至265KB。
- 结合降质参数和WebP格式，最终大小仅为78KB，下降了93%。
- 此外，我们将主光效换成放大一倍的一倍图，并通过CSS属性scale实现放大，进一步节省资源。
- 流量消峰，页面随机加载1-3秒 loading 后跳转到活动页面
- 流量消峰，游戏时长次数随机，完成要求随机
- 选择了localStorage作为优化方案。它具有较长的生命周期和较大的储存空间（2.5M-4M），能满足业务需求。
- 采用localStorage缓存数据，不仅可以简化调用链路、降低风险和节约成本，
- 还能直接从本地读取券的领取状态，避免网络延迟导致的响应时间过长，提升用户体验。
- 在静态资源优化方面，团队通过首屏资源拆分、帧动画方案替代3D模型、动态雪碧图和WebP格式优化等技术手段，显著降低了资源消耗和请求次数。
- 在降低服务器成本及风险方面，选择localStorage作为非常规优化方案，提升用户体验。在容错方面，流量削峰和降级处理，确保系统稳定运行。
- 在工程化方面，统一处理通用解决方案、提供拟真的MOCK环境和编写稳定高效的发布脚本，降低开发难度，确保每个环境稳定部署。

## BFF

- 透传、转发
- 业务逻辑串联
- 数据聚合
- 服务端渲染

## 工程化、模块化 

- 工具化：以针对各自业务场景开发脚手架为主，内置常用的前端组件库，提供代码格式检查、埋点及监控等插件，提升项目初始化的效率。
- 规范化：面向完成需求的整个研发流程，梳理需求管理、视觉交互设计、评审、开发、联调、测试验收、上线部署和质量监控等相关的规范，进一步建设工具来约束研发过程中的不确定性。
- 平台化：将支撑研发的有关工具和系统聚合起来，通过套件和插件的设计模式，实现对不同场景的支撑，支持在线初始化项目，横向打通研发的整体链路。
- 体系化：紧跟前沿技术，集成低代码、在线IDE、代码智能生成或推荐等能力，建设需求、设计、研发、运营一体化的云开发平台。

- `原始模块：`一个函数即可称为一个模块。这个是最常见的，最简单的模块。
- `AMD` 是一种异步模块加载规范，专为浏览器端设计，浏览器并不支持 AMD 模块，在浏览器端，需要借助 RequireJS 才能加载 AMD 模块
- `CommonJS` 是一种同步模块加载规范，目前主要用于 Node.js 环境中。
- `UMD` 是一种通用模块加载规范，UMD 规范是对不同模块规范的简单整合。
- `ES Module` 是 ES6 带来的原生系统。目前部分浏览器已经支持直接使用，而不兼容的浏览器可以通过构建工具来使用。

## webpack

- JS 模块打包工具
  - 通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用
  - `打包功能` 和一套 `文件处理机制`，然后通过生态中的各种 `Loader` 和 `Plugin` 对代码进行预编译和打包

- Entry: 入口文件，Webpack 会从该文件开始进行分析与编译；
- Output: 出口路径，打包后创建 bundler 的文件路径以及文件名；
- Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；
- Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；
- Loader: 模块加载器，进行各种文件类型的加载与转换；
- Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；

### 工作流程 (加载 - 编译 - 输出)

1. 读取配置文件，按命令 `初始化` 配置参数，创建 `Compiler` 对象；
2. 调用插件的 `apply` 方法 `挂载插件` 监听，然后从入口文件开始执行编译；
3. 按文件类型，调用相应的 `Loader` 对模块进行 `编译`，并在合适的时机点触发对应的事件，调用 `Plugin` 执行，最后再根据模块 `依赖查找` 到所依赖的模块，递归执行第三步；
4. 将编译后的所有代码包装成一个个代码块 (`Chuck`)， 并按依赖和配置确定 `输出内容`。这个步骤，仍然可以通过 Plugin 进行文件的修改;
5. 最后，根据 `Output` 把文件内容一一写入到指定的文件夹中，完成整个过程；

- `模块机制`: webpack 自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制；
- `文件编译`: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理；

### Loader

- Webpack 其实是`只能识别 js 模块`，`Loader 不同格式文件转换器`，对 Webpack 传入的字符串进行按需修改
- 将代码进行分析，`构建 AST (抽象语法树)`， 遍历进行定向的修改后，再重新生成新的代码字符串

*** `Babel-loader` 会执行以下步骤: ***

1. babylon 将 ES6/ES7 代码解析成 AST
2. babel-traverse 对 AST 进行遍历转译，得到新的 AST
3. 新 AST 通过 babel-generator 转换成 ES5

**Loader 特性:**

- `链式传递`，按照配置时相反的顺序链式执行；
- 基于 Node 环境，拥有 `较高权限`，比如文件的增删查改；
- 可同步也可异步；

**编写原则:**

- `单一原则`: 每个 Loader 只做一件事；
- `链式调用`: Webpack 会按顺序链式调用每个 Loader；
- `统一原则`: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

### Plugin

见网页

## vite

- esbuild（10～100 倍）（go 直接转机器码、go 多线程共享内存、多核 cpu、零造轮子、复用 AST 节点）

   - 预构建依赖
   - go 直接转机器码，而非 js 先解析字节码再转机器码，js 解释性语言，go 编译性语言
   - go 多线程共享内存、多核 cpu 运行打包算法
   - 零造轮子
   - 复用 AST 节点，高效的内存利用
   - 在资源打包这种 CPU 密集场景下，Go 性能更优。一般来说，JS 的操作是毫秒级，而 Go 则是纳秒级。
   - js：解释运行、parse、解释运行、link、解释运行、generation
   - go：parse、link、generation
   - Go 在线程之间共享内存，而 js 必须在线程之间序列化数据。
   - Go 和 JavaScript 都有`并行的垃圾收集器`，Go 的堆在`所有线程之间共享`，而每个 JS 线程中都有一个`单独的堆`。

- rollup

- rolldown
 3.8号开源，基于 rust 的 js 打包器，为 vite 设计，兼容 rollup  api 和插件体系，贴近 esbulid 设计理念

## Rust

vivo 蓝河操作系统采用 Rust 编写「系统框架」—— 从源头避免了内存使用不当引起的安全漏洞

- 高性能 内存利用率极高、没有运行时和垃圾回收
- 可靠性 丰富的类型系统和所有权模型保证了`内存安全和线程安全`
- 生产力 出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具 —— 包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等

Rust 语言可以用于开发：

- 传统命令行程序 - 直接生成目标可执行程序，不需要任何解释程序。
- Web 应用 - 被编译成 WebAssembly，WebAssembly 是一种 JS 的高效替代品。
  - WebAssembly，是通过虚拟机的方式，可以在服务端、客户端如浏览器等环境执行的二进制程序。他有速度快、效率高、可移植的特点。
  - 对我们 Web 前端工程最大的好处就是可以在浏览器端使用二进制程序处理一些计算量大的处理，使用他比 javascript 快的特点优化性能。
- 网络服务器 - 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。
- 嵌入式设备 - 同时具有 JS 一般的高效开发语法和 C 语言的执行效率，支持底层平台的开发。

## 前端打包工具对比

>四款前端主流的打包工具：grunt ， gulp，webpack， rollup，以发布时间为顺序。

### Grunt：

最老牌的打包工具，它`运用配置的思想来写打包脚本，一切皆配置`，所以会出现比较多的配置项，诸如option,src,dest等等。而且不同的插件可能会有自己扩展字段，认知成本高，运用的时候需要明白各种插件的配置规则。

MPA，老牌打包工具，基于文件为媒介（运行慢，零散的脚本文件一当多起来就受到影响

### Gulp：

用代码方式来写打包脚本，并且代码采用流式的写法，只抽象出了gulp.src, gulp.pipe, gulp.dest, gulp.watch 接口，运用相当简单。更易于学习和使用，使用gulp的代码量能比grunt少一半左右。

MPA，易学，基于 nodejs 的 steam 流打包

### webpack: 

是模块化管理工具和打包工具。通过 loader 的转换，任何形式的资源都可以视作模块，比如 Commonjs 模块、AMD 模块、ES6 模块、css、图片等。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。它定位是模块打包器，而 Gulp/Grunt 属于构建工具。Webpack 可以代替 Gulp/Grunt 的一些功能，但不是一个职能的工具，可以配合使用。

SPA，目前最强大的打包工具，但是过于臃肿，如何单纯打包js不推荐

### Rollup：

下一代 ES6 模块化工具，最大的亮点是利用 ES6 模块设计，利用 tree-shaking生成更简洁、更简单的代码。一般而言，对于应用使用 Webpack，对于类库使用 Rollup；需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多 Commonjs 模块的依赖时，使用 webpack。代码库是基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 Rollup。

MPA，tree-shaking特性（针对es6，按需打包，多余的不要，目前（2018，vuex,react主流使用）

## ES6

- let、const
- 解构
- Set、WeakSet、Map、WeakMap
  - WeakSet 结构与 Set 类似，也是不重复的值的集合。WeakSet 的成员只能是对象和 Symbol 值
  - WeakSet 中的对象都是弱引用
- Proxy

```js
var obj = new Proxy({}, {
  get: function (target, propKey, receiver) {
      console.log(`getting ${propKey}!`);
      return Reflect.get(target, propKey, receiver);
  },
  set: function (target, propKey, value, receiver) {
      console.log(`setting ${propKey}!`);
      return Reflect.set(target, propKey, value, receiver);
  }
});
```

## TS

### type 和 interface 的异同

**同：**
1. 都可以描述一个对象或者函数
2. 都允许拓展（extends）

**不同：**
1. type 可以声明基本类型别名，联合类型，元组等类型
2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值
3. `type StringOrNumber = string | number;`  
4. `type Text = string | { text: string };`  
5. `type NameLookup = Dictionary<string, Person>;`  
6. `type Callback<T> = (data: T) => void; `
7. `type Pair<T> = [T, T]; ` 
8. `type Coordinates = Pair<number>; ` 
9. `type Tree<T> = T | { left: Tree<T>, right: Tree<T> };`

1. interface 能够声明合并






