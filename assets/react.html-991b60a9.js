import{_ as a,o as t,c,e as r}from"./app-f5876168.js";const d={};function h(o,e){return t(),c("div",null,e[0]||(e[0]=[r('<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h1><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料" aria-hidden="true">#</a> 资料</h2><ol><li><code>React 英文</code>官方文档：https://react.dev/</li><li><code>React 中文</code>官方稳定：https://zh-hans.react.dev/</li><li><code>Redux</code> 英文官方文档：https://redux.js.org/</li><li><code>React Router</code> 英文官方文档：https://reactrouter.com/en/main</li><li><code>UmiJS</code> 文档：https://umijs.org/</li><li><code>Ant Design</code> 文档：https://ant-design.antgroup.com/index-cn</li><li><code>React 知识图谱</code>：https://www.processon.com/view/link/617d4f9f7d9c0850adca0be0</li><li><code>React 哲学</code>：https://zh-hans.react.dev/learn/thinking-in-react</li><li><code>React 源码</code>：https://github.com/facebook/react</li></ol><h2 id="react-内容" tabindex="-1"><a class="header-anchor" href="#react-内容" aria-hidden="true">#</a> React 内容</h2><p>文档：https://zh-hans.react.dev/learn/describing-the-ui</p><h3 id="jsx" tabindex="-1"><a class="header-anchor" href="#jsx" aria-hidden="true">#</a> JSX</h3><p>https://zh-hans.react.dev/learn/writing-markup-with-jsx</p><h3 id="props" tabindex="-1"><a class="header-anchor" href="#props" aria-hidden="true">#</a> props</h3><p>https://zh-hans.react.dev/learn/passing-props-to-a-component</p><h3 id="类组件-不推荐" tabindex="-1"><a class="header-anchor" href="#类组件-不推荐" aria-hidden="true">#</a> 类组件（不推荐）</h3><p>虽然不推荐使用了，但是之前旧版本很多代码可能需要维护。</p><p>类组件：https://zh-hans.legacy.reactjs.org/docs/react-component.html</p><p>生命周期：https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</p><h3 id="函数组件" tabindex="-1"><a class="header-anchor" href="#函数组件" aria-hidden="true">#</a> 函数组件</h3><p>https://zh-hans.react.dev/reference/react/hooks</p><h2 id="react-18-新特性" tabindex="-1"><a class="header-anchor" href="#react-18-新特性" aria-hidden="true">#</a> React 18 新特性</h2><h3 id="concurrent" tabindex="-1"><a class="header-anchor" href="#concurrent" aria-hidden="true">#</a> Concurrent</h3><p><code>Concurrent</code> 最主要的特点就是<code>渲染是可中断的</code>。</p><p>没错，以前是不可中断的，也就是说，以前 React 中的 update 是同步渲染，在这种情况下，一旦 update 开启，在任务完成前，都不可中断。</p><blockquote><p>注意：这里说的同步，和setState所谓的同步异步不是一码事，而且setState所谓的异步本质上是个批量处理。</p></blockquote><p>在 <code>Concurrent</code> 模式下，<code>update 开始了也可以中断</code>，晚点再继续嘛，当然<code>中间也可能被遗弃掉</code>。</p><p>Concurrent 并不是 API 之类的新特性，但是呢，它很重要，因为它是 React18 大部分新特性的实现基础，包括 <code>Suspense、transitions、流式服务端渲染</code>等。</p><h4 id="可中断" tabindex="-1"><a class="header-anchor" href="#可中断" aria-hidden="true">#</a> 可中断</h4><p>对于复杂项目来说，任务<code>可中断</code>这件事情很重要。那么问题来了，React 是如何做到的呢，其实基础还是 fiber，fiber 本身链表结构，就是指针嘛，想指向别的地方加个属性值就行了。</p><h4 id="被遗弃" tabindex="-1"><a class="header-anchor" href="#被遗弃" aria-hidden="true">#</a> 被遗弃</h4><p>在 Concurrent 模式下，有些 update 可能会<code>被遗弃掉</code>。</p><h4 id="状态复用" tabindex="-1"><a class="header-anchor" href="#状态复用" aria-hidden="true">#</a> 状态复用</h4><p>Concurrent 模式下，还<code>支持状态的复用</code>。React 正在用 <code>Offscreen</code> 组件来实现这个功能。</p><p>使用 OffScreen，除了可以复用原先的状态，我们也可以使用它来当做新 UI 的缓存准备，就是虽然新 UI 还没登场，但是可以先在后台准备着嘛，这样一旦轮到它，就可以立马快速地渲染出来。</p>',29)]))}const i=a(d,[["render",h],["__file","react.html.vue"]]);export{i as default};
