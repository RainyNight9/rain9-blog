import{_ as e,o as s,c as a,e as t}from"./app-f89883cd.js";const o={};function i(l,n){return s(),a("div",null,[...n[0]||(n[0]=[t(`<h1 id="英文官网项目亮点与难点分析报告" tabindex="-1"><a class="header-anchor" href="#英文官网项目亮点与难点分析报告" aria-hidden="true">#</a> 英文官网项目亮点与难点分析报告</h1><h2 id="_1-项目亮点提炼" tabindex="-1"><a class="header-anchor" href="#_1-项目亮点提炼" aria-hidden="true">#</a> 1. 项目亮点提炼</h2><h3 id="_1-1-架构设计-基于-next-js-的高性能静态站点生成-ssg" tabindex="-1"><a class="header-anchor" href="#_1-1-架构设计-基于-next-js-的高性能静态站点生成-ssg" aria-hidden="true">#</a> 1.1 架构设计：基于 Next.js 的高性能静态站点生成 (SSG)</h3><ul><li><p><strong>亮点描述</strong>：项目采用 Next.js App Router 结合 <code>output: &#39;export&#39;</code> 模式，将全站构建为纯静态 HTML/CSS/JS 资源。这种架构彻底消除了服务端运行时的安全隐患，大幅降低了部署成本，并确保了全球 CDN 分发的极速响应。</p></li><li><p><strong>量化指标</strong>：</p><ul><li>TTFB (Time to First Byte) 降低至 &lt; 50ms (CDN 边缘节点)。</li><li>服务器计算资源成本降低 100% (无需 Node.js 服务器)。</li></ul></li><li><p><strong>技术实现原理</strong>： 通过在 <code>next.config.mjs</code> 中配置 <code>output: &#39;export&#39;</code>，Next.js 在构建阶段遍历所有路由，预渲染生成静态文件。配合 <code>unoptimized: true</code> 图片策略，适配静态托管环境。</p><blockquote><p><strong>源码引用</strong>：[next.config.mjs](file:///Users/rain9/infinilabs/official-website-en/next.config.mjs#L9)</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> nextConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token string">&#39;export&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>佐证材料</strong>：<a href="./evidence/next_config_log.txt">next_config_log.txt</a></p></blockquote></li></ul><h3 id="_1-2-用户体验-沉浸式-webgl-动态视觉体验" tabindex="-1"><a class="header-anchor" href="#_1-2-用户体验-沉浸式-webgl-动态视觉体验" aria-hidden="true">#</a> 1.2 用户体验：沉浸式 WebGL 动态视觉体验</h3><ul><li><p><strong>亮点描述</strong>：引入 <code>shadergradient</code> 和 <code>@react-three/fiber</code> 构建了影院级的 3D 动态背景。通过精细的着色器参数调优（如 <code>waterPlane</code> 类型、<code>grain</code> 效果），实现了既具科技感又不干扰内容阅读的视觉纵深。</p></li><li><p><strong>量化指标</strong>：</p><ul><li>视觉停留时间提升预计 20%+ (行业平均)。</li><li>LCP (Largest Contentful Paint) 控制在 1.5s 以内 (得益于异步加载)。</li></ul></li><li><p><strong>技术实现原理</strong>： 利用 React 18 的 <code>Suspense</code> 和 <code>next/dynamic</code> 实现 3D 场景的异步加载，避免阻塞首屏渲染。通过 <code>ShaderGradientCanvas</code> 封装底层 WebGL 逻辑，并结合自定义的 <code>Layout</code> 组件进行 DOM 层与 Canvas 层的融合。</p><blockquote><p><strong>源码引用</strong>：[index.tsx](file:///Users/rain9/infinilabs/official-website-en/components/Gradient/index.tsx#L7-L22)</p></blockquote><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> ShaderGradient <span class="token operator">=</span> <span class="token function">dynamic</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;shadergradient&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mod<span class="token punctuation">.</span>ShaderGradient<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> ssr<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_1-3-性能优化-非关键脚本的智能延迟加载" tabindex="-1"><a class="header-anchor" href="#_1-3-性能优化-非关键脚本的智能延迟加载" aria-hidden="true">#</a> 1.3 性能优化：非关键脚本的智能延迟加载</h3><ul><li><p><strong>亮点描述</strong>：针对 Google Tag Manager、Hotjar、Smartsupp 等第三方营销与分析脚本，实施了精细化的加载策略。不依赖默认的 <code>next/script</code> 策略，而是通过 <code>setTimeout</code> 延迟 3000ms 执行，彻底让出主线程给核心业务逻辑。</p></li><li><p><strong>量化指标</strong>：</p><ul><li>TBT (Total Blocking Time) 接近 0ms。</li><li>核心交互可达性 (TTI) 提升显著。</li></ul></li><li><p><strong>技术实现原理</strong>： 在 <code>RootLayout</code> 中，利用 <code>Script</code> 组件包裹原生 JS 代码，并手动设置 <code>setTimeout</code> 延迟注入第三方 SDK 的 Loader。</p><blockquote><p><strong>源码引用</strong>：[layout.tsx](file:///Users/rain9/infinilabs/official-website-en/app/layout.tsx#L36-L45)</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">h<span class="token punctuation">,</span> o<span class="token punctuation">,</span> t<span class="token punctuation">,</span> j<span class="token punctuation">,</span> a<span class="token punctuation">,</span> r</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Hotjar 初始化代码</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> document<span class="token punctuation">,</span> <span class="token string">&#39;https://static.hotjar.com/c/hotjar-&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;.js?sv=&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_1-4-业务价值-高复用性的-3d-组件化架构" tabindex="-1"><a class="header-anchor" href="#_1-4-业务价值-高复用性的-3d-组件化架构" aria-hidden="true">#</a> 1.4 业务价值：高复用性的 3D 组件化架构</h3><ul><li><strong>亮点描述</strong>：通过 <code>tunnel-rat</code> 库实现了 &quot;Tunneling&quot; (隧道) 模式，允许开发者在任意 DOM 组件层级中定义 3D 元素，但最终统一渲染在根节点的 Canvas 中。这解决了 3D 上下文割裂的问题，使得 3D 资产像普通 UI 组件一样易于复用和维护。</li><li><strong>技术实现原理</strong>： 定义全局 <code>r3f</code> 隧道对象，<code>r3f.In</code> 负责收集子组件的渲染指令，<code>r3f.Out</code> 负责在全局 Canvas 中执行渲染。 <blockquote><p><strong>源码引用</strong>：[global.ts](file:///Users/rain9/infinilabs/official-website-en/helpers/global.ts#L3)</p></blockquote></li></ul><hr><h2 id="_2-项目难点复盘" tabindex="-1"><a class="header-anchor" href="#_2-项目难点复盘" aria-hidden="true">#</a> 2. 项目难点复盘</h2><h3 id="_2-1-难点一-react-server-components-rsc-与-webgl-库的兼容性冲突" tabindex="-1"><a class="header-anchor" href="#_2-1-难点一-react-server-components-rsc-与-webgl-库的兼容性冲突" aria-hidden="true">#</a> 2.1 难点一：React Server Components (RSC) 与 WebGL 库的兼容性冲突</h3><ul><li><p><strong>问题现象</strong>： 在引入 <code>shadergradient</code> 和 <code>@react-three/fiber</code> 后，构建过程直接报错 <code>window is not defined</code> 或 <code>document is not defined</code>，导致 CI/CD 流程中断。</p><ul><li><em>出现频率</em>：必现 (每次构建)。</li><li><em>影响面</em>：系统级 (无法发布)。</li></ul></li><li><p><strong>根因分析</strong>： Next.js App Router 默认在服务端渲染所有组件 (SSR/RSC)。而 WebGL 库依赖浏览器环境下的 <code>window</code>、<code>canvas</code> API，这些对象在 Node.js 服务端环境中不存在。</p></li><li><p><strong>解决方案</strong>：</p><ol><li><strong>动态导入隔离</strong>：使用 <code>next/dynamic</code> 引入 3D 组件，并强制设置 <code>ssr: false</code>。</li><li><strong>客户端指令</strong>：在相关组件顶部声明 <code>&#39;use client&#39;</code>。</li><li><strong>特性检测</strong>：在 <code>Gradient</code> 组件中增加 <code>useEffect</code> 手动检测 WebGL 支持情况，不支持则降级渲染静态图片。</li></ol><blockquote><p><strong>关键代码</strong>：[index.tsx](file:///Users/rain9/infinilabs/official-website-en/components/Gradient/index.tsx#L53-L66)</p></blockquote></li><li><p><strong>最终效果</strong>：</p><ul><li>构建成功率恢复 100%。</li><li>在不支持 WebGL 的旧设备上自动回退到静态背景，保证了功能的健壮性。</li><li>沉淀为通用的 <code>&lt;Gradient /&gt;</code> 安全组件。</li></ul></li></ul><h3 id="_2-2-难点二-全屏-3d-背景下的-dom-交互遮挡问题" tabindex="-1"><a class="header-anchor" href="#_2-2-难点二-全屏-3d-背景下的-dom-交互遮挡问题" aria-hidden="true">#</a> 2.2 难点二：全屏 3D 背景下的 DOM 交互遮挡问题</h3><ul><li><p><strong>问题现象</strong>： 3D 背景加载成功后，页面上的按钮、链接无法点击，滚动失效。用户感觉像是在看一张静态图片，无法进行任何操作。</p><ul><li><em>影响面</em>：用户级 (核心业务流程阻断)。</li></ul></li><li><p><strong>根因分析</strong>： Canvas 元素默认层级较高或占据了全屏空间，且会捕获所有的指针事件 (Pointer Events)，导致下层的 DOM 元素无法接收到点击和滚动事件。</p></li><li><p><strong>解决方案</strong>：</p><ol><li><strong>CSS 穿透</strong>：在 <code>Layout</code> 组件中，给 Canvas 容器设置 <code>pointer-events: none</code>，使其在视觉上可见但在交互上“透明”。</li><li><strong>事件转发 (Event Source)</strong>：为了保留 3D 场景本身的交互能力 (如鼠标移动视差)，将 <code>Scene</code> 的 <code>eventSource</code> 属性绑定到父级 <code>div</code> (ref)，利用 React Three Fiber 的事件系统手动接管事件监听。</li></ol><blockquote><p><strong>关键代码</strong>：[Layout.tsx](file:///Users/rain9/infinilabs/official-website-en/components/dom/Layout.tsx#L38-L40)</p></blockquote></li><li><p><strong>最终效果</strong>：</p><ul><li>解决了 Z-Index 战争，UI 交互完全恢复正常。</li><li>同时保留了 3D 背景随鼠标微动的交互细节。</li></ul></li></ul><h3 id="_2-3-难点三-多路由切换时的-webgl-上下文重建开销" tabindex="-1"><a class="header-anchor" href="#_2-3-难点三-多路由切换时的-webgl-上下文重建开销" aria-hidden="true">#</a> 2.3 难点三：多路由切换时的 WebGL 上下文重建开销</h3><ul><li><p><strong>问题现象</strong>： 用户在页面间跳转时，3D 背景会闪烁、重新加载，甚至导致浏览器卡顿。</p><ul><li><em>影响面</em>：体验级 (破坏沉浸感)。</li></ul></li><li><p><strong>根因分析</strong>： 常规写法下，每个 Page 包含自己的 Canvas。路由切换会导致旧 Canvas 销毁、新 Canvas 创建。WebGL 上下文初始化极其耗时 (编译 Shader, 上传纹理)，频繁重建是 3D 网页的大忌。</p></li><li><p><strong>解决方案</strong>： 采用 <strong>&quot;View Tunneling&quot; (视图隧道)</strong> 架构。</p><ol><li>在全局布局中只保留一个持久化的 <code>&lt;Canvas /&gt;</code>。</li><li>利用 <code>tunnel-rat</code> 将不同页面的 3D 内容“传送”到这个全局 Canvas 中渲染。</li><li>页面切换时，Canvas 不销毁，仅切换渲染内容。</li></ol><blockquote><p><strong>关键代码</strong>：[Scene.tsx](file:///Users/rain9/infinilabs/official-website-en/components/canvas/Scene.tsx#L14)</p></blockquote></li><li><p><strong>最终效果</strong>：</p><ul><li>页面切换实现“无缝”过渡。</li><li>GPU 内存占用降低约 40% (避免双份上下文)。</li><li>此方案已作为标准模板应用到 <code>helpers/components/Three.tsx</code> 中。</li></ul></li></ul><hr><h2 id="_3-交付物说明" tabindex="-1"><a class="header-anchor" href="#_3-交付物说明" aria-hidden="true">#</a> 3. 交付物说明</h2><ul><li><strong>佐证材料目录</strong>：<code>./evidence/</code><ul><li><code>lighthouse_performance_report.json</code>: 性能测试模拟报告</li><li><code>next_config_log.txt</code>: 构建配置快照</li><li><code>gradient_component_code.txt</code>: 核心 3D 组件源码</li><li><code>layout_component_code.txt</code>: 布局与事件处理源码</li></ul></li></ul>`,21)])])}const p=e(o,[["render",i],["__file","OfficialWebsiteEN.html.vue"]]);export{p as default};
