import{_ as o,o as d,c,e as i}from"./app-f89883cd.js";const l={};function t(a,e){return d(),c("div",null,[...e[0]||(e[0]=[i('<h1 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> vite</h1><ul><li>esbuild（10～100 倍）（go 直接转机器码、go 多线程共享内存、多核 cpu、零造轮子、复用 AST 节点）</li><li>rollup</li></ul><p>Vite 作为 Vue 团队出品的构建工具，其超快的<code>冷启动以及热更新</code>速度让它迅速🔥起来了。</p><p>由于浏览器开始原生支持 <code>ES 模块</code>，Vite 巧妙的利用生态系统中的新进展解决了 Webpack 构建速度慢，HMR(热更新)迟钝等问题。</p><p>Vite 作为思维比较前卫且先进的构建工具。</p><h2 id="_1-如何指定-vite-插件-的执行顺序" tabindex="-1"><a class="header-anchor" href="#_1-如何指定-vite-插件-的执行顺序" aria-hidden="true">#</a> 1. 如何指定 vite 插件 的执行顺序？</h2><p>可以使用 <code>enforce</code> 修饰符来强制插件的位置:</p><ul><li><code>pre</code>：在 Vite 核心插件之前调用该插件</li><li><code>默认</code>：在 Vite 核心插件之后调用该插件</li><li><code>post</code>：在 Vite 构建插件之后调用该插件</li></ul><h2 id="_2-vite-插件-常见的-hook-有哪些" tabindex="-1"><a class="header-anchor" href="#_2-vite-插件-常见的-hook-有哪些" aria-hidden="true">#</a> 2. vite 插件 常见的 hook 有哪些？</h2><p><code>hook</code>: 即钩子。Vite 会在生命周期的不同阶段中去调用不同的插件以达到不同的目的.</p><ul><li><code>config</code>： 可用于修改 vite config，用户可以通过这个 hook 修改 config；例如 vite-aliases 这个插件可以帮助我们自动生成别名。它利用的就是这个钩子。</li><li><code>configResolved</code>： 在解析 Vite 配置后调用，用于获取解析完毕的 config，在这个 hook 中不建议修改 config。</li><li><code>configureServer</code>： 用于给 dev server 添加自定义 middleware；例如 vite-plugin-mock 插件就是在这个生命周期调用的。</li><li><code>configurePreviewServer</code>：与 configureServer 相同但是作为预览服务器。vite preview 插件就是利用这个钩子。</li><li><code>transformIndexHtml</code>：注入变量，用来转换 HTML 的内容。vite-plugin-html 插件可以帮助我们在 html 里注入变量，就是利用这个钩子。</li><li><code>handleHotUpdate</code>：执行自定义 HMR 更新处理</li></ul><h2 id="_3-vite是否支持-commonjs-写法" tabindex="-1"><a class="header-anchor" href="#_3-vite是否支持-commonjs-写法" aria-hidden="true">#</a> 3. Vite是否支持 commonjs 写法？</h2><p>纯业务代码，一般建议采用 <code>ESM</code> 写法。如果引入的三方组件或者三方库采用了 <code>CJS</code> 写法，<code>vite</code> 在预构建的时候就会将 <code>CJS</code> 模块转化为 <code>ESM</code> 模块。</p><p>如果非要在业务代码中采用 <code>CJS</code> 模块，那么我们可以提供一个 <code>vite</code> 插件，定义 <code>load hook</code>，在 <code>hook</code> 内部识别是 <code>CJS</code> 模块还是 <code>ESM</code> 模块。如果是 <code>CJS</code> 模块，利用 <code>esbuild</code> 的 <code>transfrom</code> 功能，将 <code>CJS</code> 模块转化为 <code>ESM</code> 模块。</p><h2 id="_4-为什么说-vite-比-webpack-要快" tabindex="-1"><a class="header-anchor" href="#_4-为什么说-vite-比-webpack-要快" aria-hidden="true">#</a> 4. 为什么说 vite 比 webpack 要快</h2><p>和 <code>webpack</code> 对比，为什么 <code>vite</code> 的冷启动、热启动、热更新都会快？这就要说说二者的区别。</p><p>使用 <code>webpack</code> 时，从 <code>yarn start</code> 命令启动，到最后页面展示，需要经历的过程：</p><ol><li>以 <code>entry</code> 配置项为起点，做一个全量的打包，并生成一个入口文件 <code>index.html</code> 文件；</li><li>启动一个 <code>node</code> 服务；</li><li>打开浏览器，去访问入 <code>index.html</code>，然后去加载已经打包好的 <code>js、css</code> 文件；</li></ol><p>在整个工作过程中，最重要的就是第一步中的全量打包，中间涉及到构建 <code>module graph</code> (涉及到大量度文件操作、文件内容解析、文件内容转换)、<code>chunk</code> 构建，这个需要消耗大量的时间。尽管在二次启动、热更新过程中，在构建 <code>module graph</code> 中可以充分利用缓存，但随着项目的规模越来越大，整个开发体验也越来越差。</p><blockquote><p>在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：<code>使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件</code>。诸如 webpack、Rollup 和 Parcel 等工具应运而生。</p></blockquote><blockquote><p>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。</p></blockquote><p>使用 <code>vite</code> 时， 从 <code>vite</code> 命令启动，到最后的页面展示，需要经历的过程：</p><ol><li>使用 <code>esbuild</code> 预构建依赖，提前将项目的第三方依赖格式化为 <code>ESM</code> 模块；</li><li>启动一个 <code>node</code> 服务；</li><li>打开浏览器，去访问 <code>index.html</code>；</li><li>基于浏览器已经支持原生的 <code>ESM</code> 模块, 逐步去加载入口文件以及入口文件的依赖模块。浏览器发起请求以后，<code>dev server</code> 端会通过 <code>middlewares</code> 对请求做拦截，然后对源文件做 <code>resolve、load、transform、parse</code> 操作，然后再将转换以后的内容发送给浏览器。</li></ol><p>在第四步中，<code>vite</code> 需要逐步去加载入口文件以及入口文件的依赖模块，但在实际应用中，这个过程中涉及的模块的数量级并不大，需要的时间也较短。而且在分析模块的依赖关系时， <code>vite</code> 采用的是 <code>esbuild</code>，<code>esbuild</code> 使用 <code>Go</code> 编写，比以 <code>JavaScript</code> 编写的打包器预构建依赖快 <code>10-100</code> 倍（webpack 就是采用 js ）</p><p>综上，开发模式下 <code>vite</code> 比 <code>webpack</code> 快的原因：</p><ol><li><code>vite</code> 不需要做全量的打包，这是比 <code>webpack</code> 要快的最主要的原因；</li><li><code>vite</code> 在解析模块依赖关系时，利用了 <code>esbuild</code>，更快（<code>esbuild</code> 使用 <code>Go</code> 编写，并且比以 <code>JavaScript</code> 编写的打包器预构建依赖快 <code>10-100</code> 倍）；</li><li><code>按需加载</code>；模块之间的依赖关系的解析由浏览器实现。<code>Vite</code> 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。</li></ol><h2 id="_5-vite-对比-webpack-优缺点在哪" tabindex="-1"><a class="header-anchor" href="#_5-vite-对比-webpack-优缺点在哪" aria-hidden="true">#</a> 5. vite 对比 webpack ，优缺点在哪</h2><p><strong>优点</strong>：</p><ol><li><code>更快的冷启动</code>：<code>Vite</code> 借助了浏览器对 <code>ESM</code> 规范的支持，采取了与 <code>Webpack</code> 完全不同的 <code>unbundle</code> 机制</li><li><code>更快的热更新</code>：<code>Vite</code> 采用 <code>unbundle</code> 机制，所以 <code>dev server</code> 在监听到文件发生变化以后，只需要通过 <code>ws</code> 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了。</li></ol><p><strong>缺点</strong>：</p><ol><li><code>开发环境下首屏加载变慢</code>：由于 <code>unbundle</code> 机制，<code>Vite</code> 首屏期间需要额外做其它工作。不过首屏性能差只发生在 <code>dev server</code> 启动以后第一次加载页面时发生。之后再 <code>reload</code> 页面时，首屏性能会好很多。原因是 <code>dev server</code> 会将之前已经完成转换的内容缓存起来</li><li><code>开发环境下懒加载变慢</code>：跟首屏加载变慢的原因一样。<code>Vite</code> 在懒加载方面的性能也比 <code>Webpack</code> 差。由于 <code>unbundle</code> 机制，动态加载的文件，需要做 <code>resolve、load、transform、parse</code> 操作，并且还有大量的 <code>http</code> 请求，导致懒加载性能也受到影响。</li><li><code>webpack支持的更广</code>。由于 <code>Vite</code> 基于 <code>ES Module</code>，所以代码中不可以使用 <code>CommonJs</code>；<code>webpack</code>更多的关注兼容性, 而 <code>Vite</code> 关注浏览器端的开发体验。<code>Vite</code>目前生态还不如 <code>Webpack</code>。</li></ol><blockquote><p>当需要打包到生产环境时，Vite使用传统的rollup进行打包，所以，vite的优势是体现在开发阶段，缺点也只是在开发阶段存在。</p></blockquote>',32)])])}const p=o(l,[["render",t],["__file","vite.html.vue"]]);export{p as default};
